# -*- coding: utf-8 -*-
"""synthetic_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vqQ9tLvOLpf9TTQ8dczOVPEskRGddsKE
"""

from google.colab import files
import zipfile
import os

print("Please upload the zip file containing your images.")
uploaded_zip = files.upload()

# Get the name of the uploaded file
if uploaded_zip:
    zip_file_name = list(uploaded_zip.keys())[0]
    print(f'User uploaded file "{zip_file_name}"')

    # Update zip_file_path to the uploaded file name
    zip_file_path = zip_file_name

    # Now re-run the extraction and listing code from the previous step


    extracted_dir = 'extracted_images'

    # Create the extraction directory if it doesn't exist
    os.makedirs(extracted_dir, exist_ok=True)

    try:
        # Create a ZipFile object
        with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
            # Extract all the contents of the zip file to the designated directory
            zip_ref.extractall(extracted_dir)
        print(f"Extracted zip file contents to '{extracted_dir}'")

        # Get a list of all files in the extraction directory and its subdirectories
        image_files = []
        image_extensions = ['.jpg', '.png', '.jpeg', '.gif', '.bmp']

        for dirpath, dirnames, filenames in os.walk(extracted_dir):
            for f in filenames:
                if os.path.splitext(f)[1].lower() in image_extensions:
                    image_files.append(os.path.join(dirpath, f))

        print(f"Found {len(image_files)} image files:")
        for img_file in image_files:
            print(img_file)

    except FileNotFoundError:
        # This should not happen if files.upload was successful, but included for robustness
        print(f"Error: Zip file not found at '{zip_file_path}'. This is unexpected after upload.")
        image_files = []
    except zipfile.BadZipFile:
        print(f"Error: '{zip_file_path}' is not a valid zip file.")
        image_files = []

else:
    print("No file was uploaded.")
    image_files = [] # Ensure image_files is defined even if no file is uploaded

import cv2
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

import os
import cv2
import numpy as np
from PIL import Image
import random

def apply_augmentations(image):
    """Applies a sequence of random image augmentations to an image.

    Args:
        image: Input image as a NumPy array.

    Returns:
        Augmented image as a NumPy array.
    """
    augmented_image = image.copy()

    # Geometric Transformations
    # Random Rotation
    angle = np.random.uniform(-15, 15)
    h, w = augmented_image.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    augmented_image = cv2.warpAffine(augmented_image, M, (w, h))

    # Random Scaling
    scale_factor = np.random.uniform(0.8, 1.2)
    # Need to calculate the new dimensions after scaling to pass to cv2.resize
    new_h = int(h * scale_factor)
    new_w = int(w * scale_factor)
    augmented_image = cv2.resize(augmented_image, (new_w, new_h))

    # Color Variations
    # Random Brightness and Contrast
    alpha = np.random.uniform(0.8, 1.2)  # Contrast control
    beta = np.random.uniform(-20, 20)   # Brightness control
    augmented_image = cv2.convertScaleAbs(augmented_image, alpha=alpha, beta=beta)

    # Convert back to PIL for color jitter (more options in PIL)
    augmented_image_pil = Image.fromarray(cv2.cvtColor(augmented_image, cv2.COLOR_BGR2RGB))

    # Random Color Jitter (Brightness, Contrast, Saturation, Hue)
    from PIL import ImageEnhance

    enhancer = ImageEnhance.Brightness(augmented_image_pil)
    augmented_image_pil = enhancer.enhance(np.random.uniform(0.8, 1.2))

    enhancer = ImageEnhance.Contrast(augmented_image_pil)
    augmented_image_pil = enhancer.enhance(np.random.uniform(0.8, 1.2))

    enhancer = ImageEnhance.Color(augmented_image_pil)
    augmented_image_pil = enhancer.enhance(np.random.uniform(0.8, 1.2))

    # Convert back to OpenCV format
    augmented_image = cv2.cvtColor(np.array(augmented_image_pil), cv2.COLOR_RGB2BGR)

    # Noise Injection (Gaussian Noise)
    mean = 0
    stddev = np.random.uniform(5, 25)
    noise = np.random.normal(mean, stddev, augmented_image.shape).astype('uint8')
    augmented_image = cv2.add(augmented_image, noise)

    # Blurring (Gaussian Blur)
    kernel_size = random.choice([(3, 3), (5, 5), (7, 7)])
    augmented_image = cv2.GaussianBlur(augmented_image, kernel_size, 0)

    return augmented_image

extracted_dir = "extracted_images"
image_files = []
image_extensions = ['.jpg', '.png', '.jpeg', '.gif', '.bmp'] # Define image extensions

for dirpath, dirnames, filenames in os.walk(extracted_dir):
    for f in filenames:
        if os.path.splitext(f)[1].lower() in image_extensions:
            image_files.append(os.path.join(dirpath, f))

loaded_images = {}

for image_path in image_files:
    image = cv2.imread(image_path)

    if image is not None:
        # Use the relative path from extracted_dir as the key to preserve original directory structure information
        relative_path = os.path.relpath(image_path, extracted_dir)
        loaded_images[relative_path] = image
        print(f"Loaded image: {relative_path}")
    else:
        print(f"Error: Could not load image: {image_path}")

print(f"\nSuccessfully loaded {len(loaded_images)} images.")


num_synthetic_images_per_original = 10
synthetic_datasets = {}

if loaded_images:
    for original_filename, original_img in loaded_images.items():
        print(f"Generating synthetic images for {original_filename}...")
        synthetic_datasets[original_filename] = []
        for i in range(num_synthetic_images_per_original):
            augmented_image = apply_augmentations(original_img)
            synthetic_datasets[original_filename].append(augmented_image)
        print(f"Generated {len(synthetic_datasets[original_filename])} synthetic images for {original_filename}.")
else:
    print("No original images were loaded, cannot generate synthetic datasets.")

from PIL import Image
import os
import io
import os
import zipfile
from google.colab import files
base_output_dir = "output_synthetic_datasets"
os.makedirs(base_output_dir, exist_ok=True)

if synthetic_datasets:
    for original_filename, augmented_images in synthetic_datasets.items():
        # Get the original filename without extension
        original_name_without_ext = os.path.splitext(original_filename)[0]

        # Create subdirectory for the original image
        output_subdir = os.path.join(base_output_dir, original_name_without_ext)
        os.makedirs(output_subdir, exist_ok=True)
        print(f"Saving synthetic images for {original_filename} to {output_subdir}...")

        if augmented_images:
            for i, img in enumerate(augmented_images):
                # Construct filename with clear naming convention
                filename = os.path.join(output_subdir, f"{original_name_without_ext}_synthetic_{i+1:03d}.jpg")

                # Save the augmented image
                success = cv2.imwrite(filename, img)

                if not success:
                    print(f"Warning: Could not save image {filename}")
            print(f"Saved {len(augmented_images)} synthetic images for {original_filename}.")
        else:
            print(f"No synthetic images to save for {original_filename}.")

    print(f"\nSynthetic datasets saved to {base_output_dir}.")
else:
    print("No synthetic datasets were generated to save.")
def zip_folder(folder_path, output_path):
    """Zips the contents of a folder."""
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                zipf.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), folder_path))

# Specify the folder to download
folder_to_download = "/content/output_synthetic_datasets" # Change this to the folder you want to download

# Specify the name for the zip file
output_zip_file = "output_synthetic_datasets.zip" # Change this to your desired zip file name

print(f"Zipping folder: {folder_to_download} into {output_zip_file}")
zip_folder(folder_to_download, output_zip_file)

print(f"Initiating download of {output_zip_file}")
files.download(output_zip_file)

