# -*- coding: utf-8 -*-
"""background_remover_&_upscale.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gyQ8nR0h9qmEO0EuJCzTotD3Da5kzx2Y
"""

!pip install rembg

!pip install onnxruntime

from rembg import remove
from PIL import Image
import io
from io import BytesIO
import requests
import os



'''os.makedirs("original",exist_ok=True)
os.makedirs("masked",exist_ok=True)'''



'''img_path="/content/IMG20250624123622.jpg"'''

'''img=Image.open(img_path)
img.save("original/img1",format="jpeg")'''

'''from google.colab import files
from PIL import Image
import io
import os
from rembg import remove
from PIL import Image
import os

uploaded = files.upload()

for filename, content in uploaded.items():
  print(f'User uploaded file "{filename}"')

  # Read the image from the uploaded bytes
  img = Image.open(io.BytesIO(content))

  # Define the desired output filename (you can change this)
  output_filename = filename # Or set a specific name like "my_image.jpg"

  # Define the path to save the image in the 'original' folder
  save_path = os.path.join("original", output_filename)

  # Save the image to the 'original' folder
  img.save(save_path)
  print(f'Saved uploaded file to "{save_path}"')

  # Update img_path to the saved file's path for subsequent use
  img_path = save_path

# Load the image from the updated img_path
input_path = img_path
output_path = os.path.join("masked", os.path.basename(input_path)) # Save in 'masked' folder with original filename

with open(input_path, 'rb') as i:
    with open(output_path, 'wb') as o:
        input_data = i.read()
        result = remove(input_data)
        o.write(result)
        img = Image.open(io.BytesIO(result))

print(f"Background removed and saved to {output_path}")'''

'''from rembg import remove
from PIL import Image
import os

# Load the image from the updated img_path
input_path = "/content/extracted_images/Micraspis discolor - Copy/IMG20250624123844.jpg"
output_path = os.path.join("masked", os.path.basename(input_path)) # Save in 'masked' folder with original filename

with open(input_path, 'rb') as i:
    with open(output_path, 'wb') as o:
        input_data = i.read()
        result = remove(input_data)
        o.write(result)

print(f"Background removed and saved to {output_path}")'''

"""# Task
Explain the error in the selected code. If possible, fix the error and incorporate the changes into the existing code. Otherwise, try to diagnose the error.Explain the error in the selected code. If possible, fix the error and incorporate the changes into the existing code. Otherwise, try to diagnose the error.Explain the error in the selected code. If possible, fix the error and incorporate the changes into the existing code. Otherwise, try to diagnose the error.Explain the error in the selected code. If possible, fix the error and incorporate the changes into the existing code. Otherwise, try to diagnose the error.Explain the error in the selected code. If possible, fix the error and incorporate the changes into the existing code. Otherwise, try to diagnose the error.Explain the selected code.can you make it to save the file in "original" folderupload in "original/"there was a option to give the name of the fileyes in the time of save yescan you make it to continuous upload file from a folder

## Access the folder containing the images

### Subtask:
Explain the limitations of accessing local folders and suggest alternatives like uploading a zip file or mounting Google Drive.

**Reasoning**:
Explain the limitations of accessing local folders and suggest alternatives like uploading a zip file or mounting Google Drive.
"""

# Explanation of limitations and alternatives for accessing local files in Colab.

print("Due to security restrictions, a Colab notebook cannot directly access files on your local computer's file system.")
print("To work with multiple image files, here are a couple of alternatives:")
print("1. Upload a zip file: You can compress your images into a zip file and upload it to Colab using the `files.upload()` function. You can then use Python's `zipfile` module to extract the images within the Colab environment.")
print("2. Mount Google Drive: You can mount your Google Drive to your Colab notebook. This allows you to access files stored in your Drive directly from Colab. You can do this using `from google.colab import drive` and `drive.mount('/content/drive')`.")

"""## Get list of image files

### Subtask:
Depending on the chosen method (zip upload/extraction or Google Drive), write code to get a list of image file paths from the accessible folder.

**Reasoning**:
Based on the previous steps, the user has been interacting with file uploads using `files.upload()`, which is suitable for uploading individual files or a few files at once. To handle a folder of images as requested in the original prompt, using a zip file upload and extraction is a more scalable approach within the current workflow. The code will extract the contents of the uploaded zip file and list the image files within the extracted directory.

**Reasoning**:
The previous command failed because the specified zip file was not found. Before proceeding with processing images from a folder, the user needs to provide the zip file containing the images. The `files.upload()` function can be used for this purpose. After the user uploads the zip file, the previous extraction and listing code can be re-executed to process the uploaded file.
"""

from google.colab import files
import zipfile
import os

print("Please upload the zip file containing your images.")
uploaded_zip = files.upload()

# Get the name of the uploaded file
if uploaded_zip:
    zip_file_name = list(uploaded_zip.keys())[0]
    print(f'User uploaded file "{zip_file_name}"')

    # Update zip_file_path to the uploaded file name
    zip_file_path = zip_file_name

    # Now re-run the extraction and listing code from the previous step


    extracted_dir = 'extracted_images'

    # Create the extraction directory if it doesn't exist
    os.makedirs(extracted_dir, exist_ok=True)

    try:
        # Create a ZipFile object
        with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
            # Extract all the contents of the zip file to the designated directory
            zip_ref.extractall(extracted_dir)
        print(f"Extracted zip file contents to '{extracted_dir}'")

        # Get a list of all files in the extraction directory and its subdirectories
        image_files = []
        image_extensions = ['.jpg', '.png', '.jpeg', '.gif', '.bmp']

        for dirpath, dirnames, filenames in os.walk(extracted_dir):
            for f in filenames:
                if os.path.splitext(f)[1].lower() in image_extensions:
                    image_files.append(os.path.join(dirpath, f))

        print(f"Found {len(image_files)} image files:")
        for img_file in image_files:
            print(img_file)

    except FileNotFoundError:
        # This should not happen if files.upload was successful, but included for robustness
        print(f"Error: Zip file not found at '{zip_file_path}'. This is unexpected after upload.")
        image_files = []
    except zipfile.BadZipFile:
        print(f"Error: '{zip_file_path}' is not a valid zip file.")
        image_files = []

else:
    print("No file was uploaded.")
    image_files = [] # Ensure image_files is defined even if no file is uploaded

from rembg import remove
from PIL import Image
import os
import io
import os
import zipfile
from google.colab import files


extracted_dir = 'extracted_images'
contents = os.listdir(extracted_dir)

print(f"Contents of '{extracted_dir}':")
for item in contents:
    print(item)

# Ensure the masked directory exists
os.makedirs("masked", exist_ok=True)

# Assuming 'image_files' list contains the paths to all images from the previous step
# If you re-ran the previous cell, 'image_files' should be updated.

print(f"Processing {len(image_files)} image files for background removal...")

for input_path in image_files:
    try:
        # Determine the relative path from 'extracted_images' to the input file
        relative_path = os.path.relpath(input_path, 'extracted_images')

        # Construct the output path in the 'masked' directory, preserving subfolders
        output_path = os.path.join("masked", relative_path)

        # Ensure the output directory exists for this file
        output_dir = os.path.dirname(output_path)
        os.makedirs(output_dir, exist_ok=True)

        print(f"Processing: {input_path} -> {output_path}")

        # Open the image, remove background, and save
        with open(input_path, 'rb') as i:
            input_data = i.read()
            result = remove(input_data)

            with open(output_path, 'wb') as o:
                o.write(result)

    except Exception as e:
        print(f"Error processing {input_path}: {e}")

print("Background removal process complete.")
def zip_folder(folder_path, output_path):
    """Zips the contents of a folder."""
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                zipf.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), folder_path))

# Specify the folder to download
folder_to_download = "/content/masked" # Change this to the folder you want to download

# Specify the name for the zip file
output_zip_file = "masked_images.zip" # Change this to your desired zip file name

print(f"Zipping folder: {folder_to_download} into {output_zip_file}")
zip_folder(folder_to_download, output_zip_file)

print(f"Initiating download of {output_zip_file}")
files.download(output_zip_file)

"""# Task
Make a code to automatically increase the quality and make it high resolution of images present in the folder of masked folder "/content/masked".

## Summary:

### Data Analysis Key Findings

*   The `RealESRGANer` class, essential for the image upscaling process using the `basicsr` library, could not be imported from multiple attempted locations within the library structure.
*   This consistent import failure prevented the execution of the image upscaling logic for all masked images.

### Insights or Next Steps

*   Verify the installation of the `basicsr` library and its specific version to ensure the `RealESRGANer` class exists and is accessible.
*   Consult the documentation or source code of the installed `basicsr` library version to find the correct import path for `RealESRGANer`.
"""

!pip install torchvision

!pip install opencv-contrib-python

import cv2
import os
from PIL import Image
import numpy as np
import zipfile
from google.colab import files

# Define the path to the masked and upscaled folders
masked_folder = "masked"
upscaled_folder = "upscaled"
os.makedirs(upscaled_folder, exist_ok=True)

# --- Code to get list of masked images (moved from previous cell) ---
masked_image_files = []
image_extensions = ['.jpg', '.png', '.jpeg', '.gif', '.bmp']

for dirpath, dirnames, filenames in os.walk(masked_folder):
    for f in filenames:
        if os.path.isfile(os.path.join(dirpath, f)) and os.path.splitext(f)[1].lower() in image_extensions:
            masked_image_files.append(os.path.join(dirpath, f))
# --- End of code to get list of masked images ---


print(f"Processing {len(masked_image_files)} masked image files for upscaling with OpenCV...")

# Define the scaling factor (e.g., 2 for doubling resolution)
scale_factor = 2

for input_path in masked_image_files:
    try:
        # Determine the relative path from 'masked' to the input file
        relative_path = os.path.relpath(input_path, masked_folder)

        # Construct the output path in the 'upscaled' directory, preserving subfolders
        output_path = os.path.join(upscaled_folder, relative_path)

        # Ensure the output directory exists for this file
        output_dir = os.path.dirname(output_path)
        os.makedirs(output_dir, exist_ok=True)

        print(f"Upscaling: {input_path} -> {output_path}")

        # Read the image using OpenCV
        img = cv2.imread(input_path)

        if img is None:
            print(f"Error: Could not read image {input_path}. Skipping.")
            continue

        # Get original dimensions
        original_height, original_width = img.shape[:2]

        # Calculate new dimensions
        new_width = original_width * scale_factor
        new_height = original_height * scale_factor

        # Perform upscaling using a suitable interpolation method
        # INTER_CUBIC or INTER_LANCZOS4 are generally good for upscaling
        upscaled_img = cv2.resize(img, (new_width, new_height), interpolation=cv2.INTER_LANCZOS4)

        # Save the upscaled image
        cv2.imwrite(output_path, upscaled_img)

    except Exception as e:
        print(f"Error processing {input_path}: {e}")

print("Upscaling process complete.")


def zip_folder(folder_path, output_path):
    """Zips the contents of a folder."""
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                zipf.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), folder_path))

# Specify the folder to download
folder_to_download = "/content/upscaled" # Change this to the folder you want to download

# Specify the name for the zip file
output_zip_file = "upscale_images.zip" # Change this to your desired zip file name

print(f"Zipping folder: {folder_to_download} into {output_zip_file}")
zip_folder(folder_to_download, output_zip_file)

print(f"Initiating download of {output_zip_file}")
files.download(output_zip_file)

import os
from IPython.display import display, Image

# Define the paths to the masked and upscaled folders
masked_folder = "masked"
upscaled_folder = "upscaled"

# Get a list of image files from the masked folder (assuming upscaled has the same structure)
# Reuse the masked_image_files list if it's available and accurate, otherwise regenerate.
# Assuming masked_image_files is available from previous steps.

# If masked_image_files is not defined, uncomment and run the following block:
# masked_image_files = []
# image_extensions = ['.jpg', '.png', '.jpeg', '.gif', '.bmp']
# for dirpath, dirnames, filenames in os.walk(masked_folder):
#     for f in filenames:
#         if os.path.isfile(os.path.join(dirpath, f)) and os.path.splitext(f)[1].lower() in image_extensions:
#             masked_image_files.append(os.path.join(dirpath, f))


print(f"Displaying original and upscaled images side-by-side:")

for masked_img_path in masked_image_files:
    # Determine the relative path from 'masked' to the input file
    relative_path = os.path.relpath(masked_img_path, masked_folder)

    # Construct the full path to the corresponding upscaled image
    upscaled_img_path = os.path.join(upscaled_folder, relative_path)

    # Check if both original and upscaled files exist
    if os.path.exists(masked_img_path) and os.path.exists(upscaled_img_path):
        print(f"\n--- Comparing {relative_path} ---")

        # Display the original masked image
        print("Original Masked Image:")
        display(Image(filename=masked_img_path))

        # Display the upscaled image
        print("Upscaled Image:")
        display(Image(filename=upscaled_img_path))
    else:
        print(f"\nSkipping {relative_path}: Original or upscaled file not found.")

print("\nComparison complete.")

"""# Task
Make a code to detect ladybugs from a provided picture using object detection.

## Choose and load an object detection model

### Subtask:
Select a suitable pre-trained object detection model (e.g., a model trained on a dataset that includes insects or objects similar to ladybugs). Load the model and its necessary components.

**Reasoning**:
Install the `ultralytics` library to access YOLO models.
"""

!pip install ultralytics

"""**Reasoning**:
Import the `YOLO` class and load a pre-trained YOLO model as specified in the instructions.


"""

from ultralytics import YOLO

# Load a pre-trained YOLOv8 model
model = YOLO('yolov8n.pt')

print("YOLOv8n model loaded successfully.")

"""## Load the new image

### Subtask:
Provide or upload the image in which you want to detect the objects.

**Reasoning**:
Import necessary libraries for file upload and prompt the user to upload the image.
"""

from google.colab import files

print("Please upload the image file in which you want to detect ladybugs.")
uploaded_img = files.upload()

"""**Reasoning**:
Check if a file was uploaded, get the filename, and store it in a variable for later use.


"""

if uploaded_img:
    image_path = list(uploaded_img.keys())[0]
    print(f'User uploaded file "{image_path}"')
else:
    image_path = None
    print("No file was uploaded.")

"""## Perform object detection

### Subtask:
Use the loaded model to perform object detection on the new image. This will typically involve passing the image through the model to get bounding box coordinates and class labels for detected objects.

**Reasoning**:
Check if an image was uploaded and then use the loaded YOLO model to perform object detection on the uploaded image.
"""

if image_path is None:
    print("Error: No image was loaded in the previous step.")
else:
    # Perform object detection
    results = model(image_path)

    # Print or inspect the results
    print("Object detection results:")
    print(results)

"""## Visualize the results

### Subtask:
Visualize the results by drawing bounding boxes and labels on the image to show the detected objects.

**Reasoning**:
Check if results are available and then use the plot method to visualize the detections.
"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image

if 'results' in locals() and results:
    # Use the plot() method to draw bounding boxes and labels
    # This method returns a numpy array representation of the image with detections
    img_with_detections = results[0].plot()

    # Convert the numpy array to a PIL Image for display
    img_pil = Image.fromarray(img_with_detections)

    # Display the image in the notebook
    display(img_pil)
else:
    print("No detection results available to visualize.")

"""## Summary:

### Data Analysis Key Findings

*   The `ultralytics` library and a pre-trained YOLOv8n model were successfully loaded for object detection.
*   An image file named "IMG20250624123922.jpg" was successfully uploaded for analysis.
*   The YOLO model performed object detection on the uploaded image and identified "1 orange" and "1 donut".
*   The detected objects were successfully visualized on the image with bounding boxes and labels.

### Insights or Next Steps

*   The pre-trained YOLOv8n model did not detect ladybugs, suggesting it is not trained on a dataset that includes this class. A next step would be to fine-tune the model on a custom dataset containing images of ladybugs or use a model specifically trained for insect detection.

# Task
Train an object detection model to detect ladybugs using a provided dataset of images and annotations.

## Upload and prepare the annotated dataset

### Subtask:
Provide the dataset of images and their corresponding annotations (e.g., in YOLO, COCO, or Pascal VOC format). We'll need to ensure the data is in a format compatible with the chosen object detection framework.

**Reasoning**:
Import necessary libraries for file upload and zip file handling, then prompt the user to upload the dataset zip file. After upload, extract the contents and verify the extraction.
"""

'''from google.colab import files
import zipfile
import os

print("Please upload the zip file containing your dataset (images and annotations).")
uploaded_dataset = files.upload()

# Get the name of the uploaded file
if uploaded_dataset:
    dataset_zip_name = list(uploaded_dataset.keys())[0]
    print(f'User uploaded dataset file "{dataset_zip_name}"')

    # Define the directory to extract the dataset
    dataset_dir = 'ladybug_dataset'
    os.makedirs(dataset_dir, exist_ok=True)

    try:
        # Extract the zip file
        with zipfile.ZipFile(dataset_zip_name, 'r') as zip_ref:
            zip_ref.extractall(dataset_dir)
        print(f"Extracted dataset to '{dataset_dir}'")

        # Verify extraction by listing contents (optional, adjust as needed)
        print(f"Contents of '{dataset_dir}':")
        for item in os.listdir(dataset_dir):
            print(item)

    except FileNotFoundError:
        print(f"Error: Dataset zip file not found at '{dataset_zip_name}'. This is unexpected after upload.")
    except zipfile.BadZipFile:
        print(f"Error: '{dataset_zip_name}' is not a valid zip file.")
    except Exception as e:
        print(f"An error occurred during extraction: {e}")

else:
    print("No dataset zip file was uploaded.")'''

"""## Upload and prepare the annotated dataset (retry 1)

### Subtask:
Provide the dataset of images and their corresponding annotations (e.g., in YOLO, COCO, or Pascal VOC format). We'll need to ensure the data is in a format compatible with the chosen object detection framework.

**Reasoning**:
Prompt the user to upload the dataset zip file containing images and annotations for ladybug detection.
"""

'''from google.colab import files

print("Please upload the zip file containing your dataset (images and annotations) for ladybug detection.")
uploaded_dataset = files.upload()'''

'''!pip install diffusers transformers accelerate'''

'''from diffusers import StableDiffusionPipeline
import torch
from PIL import Image

# Load the pre-trained Stable Diffusion model
# You can choose a different model as well, e.g., "runwayml/stable-diffusion-v1-5"
model_id = "stabilityai/stable-diffusion-2-1-base"
pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
pipe = pipe.to("cuda")

# Define your prompt
prompt = "a boy"

# Generate the image
generator = torch.Generator("cuda").manual_seed(42) # for reproducible results
image = pipe(prompt, generator=generator).images[0]

# Display the generated image
display(image)

# Optionally, save the image
# image.save("astronaut_on_moon.png")'''